#!/bin/bash
# Save as ~/.local/bin/update-all
# Comprehensive system update script with AI tool reporting

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Ensure ~/.gemini/bin is in PATH
if [ -d "$HOME/.gemini/bin" ] && [[ ":$PATH:" != *":$HOME/.gemini/bin:"* ]]; then
    export PATH="$HOME/.gemini/bin:$PATH"
fi

# Arrays to track what happened
declare -a UPDATED_ITEMS=()
declare -a SKIPPED_ITEMS=()
declare -a FAILED_ITEMS=()
declare -a AVAILABLE_NOT_RUN=()
declare -a AI_TOOLS=()

# Temporary files for capturing output
APT_OUTPUT=$(mktemp)
FLATPAK_USER_OUTPUT=$(mktemp)
CLEANUP_OUTPUT=$(mktemp)

clear

show_report() {
    echo -e "\n"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                     UPDATE SUMMARY REPORT                      â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    echo -e "\n${GREEN}âœ… UPDATED (Core System):${NC}"
    if [ "${#UPDATED_ITEMS[@]}" -eq 0 ]; then
        echo "  â€¢ Nothing was updated"
    else
        for item in "${UPDATED_ITEMS[@]}"; do echo "  â€¢ $item"; done
    fi

    if [ "${#FAILED_ITEMS[@]}" -gt 0 ]; then
        echo -e "\n${RED}âŒ FAILED TO UPDATE:${NC}"
        for item in "${FAILED_ITEMS[@]}"; do echo "  â€¢ $item"; done
    fi

    echo -e "\n${BLUE}ðŸ¤– AI & DEVELOPMENT TOOLS:${NC}"
    if [ "${#AI_TOOLS[@]}" -eq 0 ]; then
        echo "  â€¢ No tool updates detected"
    else
        for tool in "${AI_TOOLS[@]}"; do echo "  â€¢ $tool"; done
    fi

    echo -e "\n${BLUE}â­ï¸  SKIPPED (Already Current):${NC}"
    if [ "${#SKIPPED_ITEMS[@]}" -eq 0 ]; then
        echo "  â€¢ No items skipped"
    else
        for item in "${SKIPPED_ITEMS[@]}"; do echo "  â€¢ $item"; done
    fi

    if [ "${#AVAILABLE_NOT_RUN[@]}" -gt 0 ]; then
        echo -e "\n${YELLOW}âš ï¸  MANUAL UPDATES REQUIRED:${NC}"
        for item in "${AVAILABLE_NOT_RUN[@]}"; do echo "  â€¢ $item"; done
    fi

    # Impact assessment
    echo -e "\n${BLUE}ðŸ“Š SYSTEM IMPACT ASSESSMENT:${NC}"
    TOTAL_UPDATED=$(printf "%s\n" "${UPDATED_ITEMS[@]}" | grep -o "[0-9]\+" | awk '{s+=$1} END {print s+0}' || echo "0")

    if [ "$TOTAL_UPDATED" -eq 0 ]; then
        echo "  âš¡ Impact: NONE - System was already fully updated"
    elif [ "$TOTAL_UPDATED" -lt 10 ]; then
        echo "  âš¡ Impact: LOW - Minor updates applied"
    else
        echo "  âš¡ Impact: MODERATE - Significant updates applied"
    fi

    # Reboot / Kernel check
    RUNNING_KERNEL=$(uname -r)
    INSTALLED_KERNEL=$(dpkg -l | grep "^ii.*linux-image-[0-9]" | grep -v "linux-image-extra" | sort -V | tail -1 | awk '{print $2}' | sed 's/linux-image-//' || echo "$RUNNING_KERNEL")

    REBOOT_REQUIRED=false
    if [ -f /var/run/reboot-required ]; then
        REBOOT_REQUIRED=true
        REBOOT_REASON=$(cat /var/run/reboot-required.pkgs 2>/dev/null | tr '\n' ' ' | sed 's/ $//')
    fi

    if [ "$RUNNING_KERNEL" != "$INSTALLED_KERNEL" ]; then
        echo -e "  ${RED}âœ– KERNEL MISMATCH: REBOOT REQUIRED${NC}"
    elif [ "$REBOOT_REQUIRED" = true ]; then
        echo -e "  ${RED}âœ– REBOOT REQUIRED${NC} $REBOOT_REASON"
    else
        echo -e "  ${GREEN}âœ“ Running the latest kernel ($RUNNING_KERNEL)${NC}"
    fi
}

trap 'rm -f "$APT_OUTPUT" "$FLATPAK_USER_OUTPUT" "$CLEANUP_OUTPUT"; show_report' EXIT

# --- CORE UPDATES ---
echo "=== Updating APT packages ==="
if sudo apt-get update 2>&1 | tee "$APT_OUTPUT"; then
    UPGRADABLE=$(apt-get upgrade --dry-run 2>/dev/null | grep -c "^Inst" || echo "0")
    if [ "$UPGRADABLE" -gt 0 ] 2>/dev/null; then
        if sudo apt-get full-upgrade -y 2>&1 | tee -a "$APT_OUTPUT"; then
            UPDATED_ITEMS+=("APT: $UPGRADABLE packages upgraded")
        else
            FAILED_ITEMS+=("APT: Upgrade failed")
        fi
    else
        SKIPPED_ITEMS+=("APT: No packages needed updating")
    fi
else
    FAILED_ITEMS+=("APT: Failed to update package lists")
fi

echo -e "\n=== Updating User Flatpaks ==="
if flatpak update -y 2>&1 | tee "$FLATPAK_USER_OUTPUT"; then
    if grep -q "Nothing to do" "$FLATPAK_USER_OUTPUT"; then
        SKIPPED_ITEMS+=("User Flatpak: Already up to date")
    else
        USER_UPDATES=$(grep -c "Installing\|Updating" "$FLATPAK_USER_OUTPUT" || echo "0")
        UPDATED_ITEMS+=("User Flatpak: $USER_UPDATES packages updated")
    fi
else
    FAILED_ITEMS+=("User Flatpak: Update failed")
fi

echo -e "\n=== Cleaning up unused packages and runtimes ==="
AUTOREMOVE_COUNT=$(sudo apt-get autoremove --dry-run 2>/dev/null | grep -c "^Remv" || echo "0")
if [ "$AUTOREMOVE_COUNT" -gt 0 ] 2>/dev/null; then
    sudo apt-get autoremove -y && UPDATED_ITEMS+=("APT cleanup: Removed $AUTOREMOVE_COUNT packages")
fi

echo "Running flatpak repair (user)..."
if flatpak repair --user 2>&1 | tee -a "$CLEANUP_OUTPUT"; then
    AI_TOOLS+=("Flatpak repair: Completed successfully")
fi

# --- AI & DEVELOPMENT TOOLS ---
echo -e "\n=== Checking AI & Development Tools ==="

if command -v docker &> /dev/null; then
    OUTDATED_IMAGES=$(docker images --filter "dangling=true" -q 2>/dev/null | wc -l || echo "0")
    if [ "$OUTDATED_IMAGES" -gt 0 ]; then AI_TOOLS+=("Docker: $OUTDATED_IMAGES dangling images") ; fi
fi

if command -v npm &> /dev/null; then
    NPM_OUTDATED=$(npm -g outdated --parseable 2>/dev/null | wc -l || echo "0")
    if [ "$NPM_OUTDATED" -gt 0 ]; then
        AI_TOOLS+=("NPM: $NPM_OUTDATED global packages outdated")
    fi
fi

if python3 -m pip --version &> /dev/null; then
    PIP_OUTDATED=$(python3 -m pip list --outdated --format=freeze 2>/dev/null | wc -l || echo "0")
    if [ "$PIP_OUTDATED" -gt 0 ]; then AI_TOOLS+=("PIP: $PIP_OUTDATED packages outdated") ; fi
fi

if command -v fwupdmgr &> /dev/null; then
    fwupdmgr refresh &>/dev/null || true
    if ! fwupdmgr get-updates 2>&1 | grep -q "No updates available"; then
        AVAILABLE_NOT_RUN+=("Firmware: Updates available")
    fi
fi
