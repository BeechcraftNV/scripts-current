#!/bin/bash
# Save as ~/.local/bin/update-all
# Comprehensive system update script with detailed reporting

# Exit on error, but we'll handle specific cases where errors are expected
set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Arrays to track what happened
declare -a UPDATED_ITEMS=()
declare -a SKIPPED_ITEMS=()
declare -a FAILED_ITEMS=()
declare -a AVAILABLE_NOT_RUN=()

# Temporary files for capturing output
APT_OUTPUT=$(mktemp)
FLATPAK_SYS_OUTPUT=$(mktemp)
FLATPAK_USER_OUTPUT=$(mktemp)
CLEANUP_OUTPUT=$(mktemp)

# Cleanup temp files on exit
trap 'rm -f "$APT_OUTPUT" "$FLATPAK_SYS_OUTPUT" "$FLATPAK_USER_OUTPUT" "$CLEANUP_OUTPUT"' EXIT

echo "=== Updating APT packages ==="
if sudo apt update 2>&1 | tee "$APT_OUTPUT"; then
    # Capture what will be upgraded before doing it
    UPGRADABLE=$(apt list --upgradable 2>/dev/null | grep -v "Listing..." | wc -l)
    
    if [ "$UPGRADABLE" -gt 0 ]; then
        sudo apt full-upgrade -y 2>&1 | tee -a "$APT_OUTPUT"
        UPDATED_ITEMS+=("APT: $UPGRADABLE packages upgraded")
    else
        SKIPPED_ITEMS+=("APT: No packages needed updating")
    fi
else
    echo "‚ö†Ô∏è APT package list update failed, skipping upgrade."
    FAILED_ITEMS+=("APT: Failed to update package lists")
fi

echo -e "\n=== Updating System Flatpaks ==="
sudo flatpak update -y 2>&1 | tee "$FLATPAK_SYS_OUTPUT"
if grep -q "Nothing to do" "$FLATPAK_SYS_OUTPUT"; then
    SKIPPED_ITEMS+=("System Flatpak: Already up to date")
else
    SYS_UPDATES=$(grep -c "Installing\|Updating" "$FLATPAK_SYS_OUTPUT" || true)
    if [ "$SYS_UPDATES" -gt 0 ]; then
        UPDATED_ITEMS+=("System Flatpak: $SYS_UPDATES packages updated")
    else
        UPDATED_ITEMS+=("System Flatpak: Updates applied")
    fi
fi

echo -e "\n=== Updating User Flatpaks ==="
flatpak update -y 2>&1 | tee "$FLATPAK_USER_OUTPUT"
if grep -q "Nothing to do" "$FLATPAK_USER_OUTPUT"; then
    SKIPPED_ITEMS+=("User Flatpak: Already up to date")
else
    USER_UPDATES=$(grep -c "Installing\|Updating" "$FLATPAK_USER_OUTPUT" || true)
    if [ "$USER_UPDATES" -gt 0 ]; then
        UPDATED_ITEMS+=("User Flatpak: $USER_UPDATES packages updated")
    else
        UPDATED_ITEMS+=("User Flatpak: Updates applied")
    fi
fi

echo -e "\n=== Cleaning up unused packages and runtimes ==="
# Remove orphaned APT packages
AUTOREMOVE_COUNT=$(sudo apt autoremove --dry-run 2>/dev/null | grep -c "^Remv" || echo "0")
if [ "$AUTOREMOVE_COUNT" -gt 0 ]; then
    sudo apt autoremove -y
    UPDATED_ITEMS+=("APT cleanup: Removed $AUTOREMOVE_COUNT orphaned packages")
else
    SKIPPED_ITEMS+=("APT cleanup: No orphaned packages")
fi

# Perform Flatpak repair and remove unused runtimes/SDKs
echo "Running flatpak repair..."
flatpak repair 2>&1 | tee -a "$CLEANUP_OUTPUT"

UNUSED_FLATPAKS=$(flatpak uninstall --unused --dry-run 2>/dev/null | grep -c "^[[:space:]]*[0-9]" || echo "0")
if [ "$UNUSED_FLATPAKS" -gt 0 ]; then
    flatpak uninstall --unused -y
    UPDATED_ITEMS+=("Flatpak cleanup: Removed $UNUSED_FLATPAKS unused runtimes/SDKs")
else
    SKIPPED_ITEMS+=("Flatpak cleanup: No unused runtimes")
fi

echo -e "\n=== Checking for EOL runtimes (example: 23.08) ==="
# Don't let this fail the script
set +e
EOL_RUNTIMES=$(flatpak list --runtime | grep "23.08" || true)
set -e

if [ -n "$EOL_RUNTIMES" ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Found EOL runtimes:${NC}"
    echo "$EOL_RUNTIMES"
    SKIPPED_ITEMS+=("EOL Flatpak runtimes detected (manual intervention needed)")
else
    echo "No EOL runtimes found."
fi

# Check for System76 firmware (Pop!_OS specific)
echo -e "\n=== Checking System76 Firmware ==="
if command -v system76-firmware-manager &> /dev/null; then
    if system76-firmware-manager --check 2>&1 | grep -qi "up-to-date\|no updates"; then
        SKIPPED_ITEMS+=("System76 Firmware: Up to date")
    else
        AVAILABLE_NOT_RUN+=("System76 firmware updates available (run: system76-firmware-manager)")
    fi
else
    echo "System76 firmware manager not found (not a System76 device or not installed)"
fi

# Check for other update sources that weren't handled
echo -e "\n=== Checking for other update sources ==="

# Check for Docker containers (but don't update them automatically)
if command -v docker &> /dev/null; then
    OUTDATED_IMAGES=$(docker images --filter "dangling=true" -q 2>/dev/null | wc -l || echo "0")
    if [ "$OUTDATED_IMAGES" -gt 0 ]; then
        AVAILABLE_NOT_RUN+=("Docker: $OUTDATED_IMAGES dangling images (not auto-updated)")
    fi
fi

# Check for pip packages
if command -v pip &> /dev/null; then
    PIP_OUTDATED=$(pip list --outdated 2>/dev/null | tail -n +3 | wc -l || echo "0")
    if [ "$PIP_OUTDATED" -gt 0 ]; then
        AVAILABLE_NOT_RUN+=("pip: $PIP_OUTDATED packages outdated (not auto-updated)")
    fi
fi

# Check for pipx packages
if command -v pipx &> /dev/null; then
    PIPX_COUNT=$(pipx list 2>/dev/null | grep -c "package" || echo "0")
    if [ "$PIPX_COUNT" -gt 0 ]; then
        AVAILABLE_NOT_RUN+=("pipx: $PIPX_COUNT packages (not auto-updated)")
    fi
fi

# Check for Rust/Cargo
if command -v rustup &> /dev/null; then
    AVAILABLE_NOT_RUN+=("rustup/cargo packages (not auto-updated)")
fi

# Check for npm global packages
if command -v npm &> /dev/null; then
    NPM_OUTDATED=$(npm outdated -g --depth=0 2>/dev/null | tail -n +2 | wc -l || echo "0")
    if [ "$NPM_OUTDATED" -gt 0 ]; then
        AVAILABLE_NOT_RUN+=("npm: $NPM_OUTDATED global packages outdated (not auto-updated)")
    fi
fi

# Check for firmware updates
if command -v fwupdmgr &> /dev/null; then
    if ! fwupdmgr refresh &>/dev/null; then
        AVAILABLE_NOT_RUN+=("Firmware updates check failed or not supported")
    elif fwupdmgr get-updates 2>&1 | grep -q "No updates available"; then
        SKIPPED_ITEMS+=("Firmware: No updates available")
    else
        AVAILABLE_NOT_RUN+=("Firmware updates available (run: fwupdmgr update)")
    fi
fi

#########################
# FINAL REPORT
#########################
echo -e "\n"
echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
echo "‚ïë                     UPDATE SUMMARY REPORT                      ‚ïë"
echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"

echo -e "\n${GREEN}‚úÖ UPDATED:${NC}"
if [ "${#UPDATED_ITEMS[@]}" -eq 0 ]; then
    echo "  ‚Ä¢ Nothing was updated"
else
    for item in "${UPDATED_ITEMS[@]}"; do
        echo "  ‚Ä¢ $item"
    done
fi

echo -e "\n${BLUE}‚è≠Ô∏è  SKIPPED (Already Current):${NC}"
if [ "${#SKIPPED_ITEMS[@]}" -eq 0 ]; then
    echo "  ‚Ä¢ No items skipped"
else
    for item in "${SKIPPED_ITEMS[@]}"; do
        echo "  ‚Ä¢ $item"
    done
fi

if [ "${#FAILED_ITEMS[@]}" -gt 0 ]; then
    echo -e "\n${RED}‚ùå FAILED:${NC}"
    for item in "${FAILED_ITEMS[@]}"; do
        echo "  ‚Ä¢ $item"
    done
fi

if [ "${#AVAILABLE_NOT_RUN[@]}" -gt 0 ]; then
    echo -e "\n${YELLOW}‚ö†Ô∏è  AVAILABLE BUT NOT AUTO-UPDATED:${NC}"
    for item in "${AVAILABLE_NOT_RUN[@]}"; do
        echo "  ‚Ä¢ $item"
    done
fi

# Impact assessment
echo -e "\n${BLUE}üìä SYSTEM IMPACT ASSESSMENT:${NC}"
echo ""

TOTAL_UPDATED=$(echo "${UPDATED_ITEMS[@]}" | grep -o "[0-9]\+" | awk '{s+=$1} END {print s+0}' || echo "0")

if [ "$TOTAL_UPDATED" -eq 0 ]; then
    echo "  ‚ö° Impact: NONE - System was already fully updated"
    echo "  üîÑ Reboot needed: No"
elif [ "$TOTAL_UPDATED" -lt 10 ]; then
    echo "  ‚ö° Impact: LOW - Minor updates applied"
    echo "  üîÑ Reboot needed: Unlikely, unless kernel/systemd updated"
    echo "     (Check: uname -r vs. dpkg -l | grep linux-image)"
else
    echo "  ‚ö° Impact: MODERATE - Significant updates applied"
    echo "  üîÑ Reboot needed: Recommended if kernel/graphics/systemd updated"
    echo "     (Check: uname -r vs. dpkg -l | grep linux-image)"
fi

# Check if kernel was updated
if grep -q "linux-image\|linux-headers" "$APT_OUTPUT" 2>/dev/null; then
    echo -e "\n  ${YELLOW}‚ö†Ô∏è  KERNEL UPDATE DETECTED - Reboot required to use new kernel${NC}"
fi

# Compare running kernel with installed kernel
echo -e "\n${BLUE}üîç KERNEL VERSION CHECK:${NC}"
RUNNING_KERNEL=$(uname -r)
INSTALLED_KERNEL=$(dpkg -l | grep "^ii.*linux-image-[0-9]" | grep -v "linux-image-extra" | sort -V | tail -1 | awk '{print $2}' | sed 's/linux-image-//')

echo "  ‚Ä¢ Currently running: $RUNNING_KERNEL"
echo "  ‚Ä¢ Latest installed:  $INSTALLED_KERNEL"

if [ "$RUNNING_KERNEL" != "$INSTALLED_KERNEL" ]; then
    echo -e "  ${RED}‚úñ MISMATCH DETECTED${NC}"
    echo -e "  ${YELLOW}‚ö†Ô∏è  REBOOT REQUIRED to load the new kernel${NC}"
else
    echo -e "  ${GREEN}‚úì Running the latest kernel${NC}"
fi

# Check if systemd or critical services were updated
if grep -q "systemd\|dbus\|udev" "$APT_OUTPUT" 2>/dev/null; then
    echo -e "\n  ${YELLOW}‚ö†Ô∏è  SYSTEM SERVICE UPDATES - Reboot recommended${NC}"
fi

echo -e "\n${BLUE}üîç WHAT WASN'T UPDATED:${NC}"
echo "  ‚Ä¢ Docker containers (manual: docker compose pull && docker compose up -d)"
echo "  ‚Ä¢ Python packages (manual: pip list --outdated or pipx upgrade-all)"
echo "  ‚Ä¢ Rust toolchain (manual: rustup update)"
echo "  ‚Ä¢ npm global packages (manual: npm update -g)"
echo "  ‚Ä¢ Manual downloads/AppImages"
echo "  ‚Ä¢ Git repositories (manual: git pull in each repo)"

echo -e "\n${BLUE}üí° RECOMMENDATIONS:${NC}"
echo "  ‚Ä¢ If Flatpaks were updated: Some apps may need restart to use new versions"
echo "  ‚Ä¢ For Docker services: Consider docker compose pull in your compose directories"
echo "  ‚Ä¢ Check running services: systemctl --failed"
echo "  ‚Ä¢ Disk space available: $(df -h / | tail -1 | awk '{print $4}') on root partition"

echo -e "\n‚úÖ Update and Cleanup Complete."
